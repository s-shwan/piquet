<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Piquet Card Game</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #2e8b57, #228b22);
            color: #fff;
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
        }
        h1 {
            color: #ffd700;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            margin-bottom: 20px;
        }
        #scores {
            font-size: 1.5em;
            font-weight: bold;
            background: rgba(0,0,0,0.7);
            padding: 10px 20px;
            border-radius: 10px;
            margin-bottom: 20px;
        }
        #game-area {
            background: rgba(255,255,255,0.1);
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            max-width: 800px;
            width: 100%;
            text-align: center;
        }
        #current-player {
            font-size: 1.2em;
            margin-bottom: 15px;
            color: #fff;
        }
        .hand {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
            margin: 20px 0;
        }
        #trick-area {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 150px;
            gap: 20px;
            margin: 20px 0;
            border: 1px dashed #ffd700;
            padding: 10px;
            border-radius: 10px;
        }
        .card {
            background: white;
            color: black;
            border: 2px solid #333;
            border-radius: 8px;
            padding: 15px;
            width: 80px;
            height: 120px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            font-size: 0.9em;
            text-align: center;
            position: relative;
        }
        .card:hover:not(.disabled) {
            transform: translateY(-5px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.4);
        }
        .card.selected {
            border-color: #ffd700;
            box-shadow: 0 0 10px #ffd700;
            transform: translateY(-5px);
        }
        .card.disabled {
            opacity: 0.6;
            cursor: default;
        }
        .card .rank {
            font-weight: bold;
            font-size: 1.2em;
        }
        .card .suit {
            font-size: 1.5em;
        }
        .hearts, .diamonds { color: red; }
        .clubs, .spades { color: black; }
        button {
            background: #ffd700;
            color: #333;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            font-size: 1em;
            cursor: pointer;
            margin: 10px;
            transition: background 0.2s;
        }
        button:hover:not(:disabled) {
            background: #ffed4e;
        }
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        #trick-result {
            margin-top: 15px;
            font-weight: bold;
            color: #ffd700;
        }
        @media (max-width: 600px) {
            .card { width: 60px; height: 90px; padding: 10px; }
            .hand { gap: 5px; }
        }
    </style>
</head>
<body>
    <h1>Piquet Card Game</h1>
    <div id="scores">Player 1: 0 | Player 2 (AI): 0</div>
    <div id="game-area">
        <div id="current-player">Player 1's turn (ecarte)</div>

        <div id="trick-area">
            <div id="p1-trick-card" class="card disabled" style="display:none;"></div>
            <div id="p2-trick-card" class="card disabled" style="display:none;"></div>
        </div>

        <div id="hand-display" class="hand"></div>
        
        <div id="controls">
            <button id="ecarte-btn">Discard Selected Cards</button>
            <button id="declare-btn" style="display:none;">Declare Combinations (Simplified)</button>
            </div>

        <div id="trick-result"></div>
    </div>

    <script>
        // Constants
        const SUITS = ['Hearts', 'Diamonds', 'Clubs', 'Spades'];
        const RANKS = ['7', '8', '9', '10', 'Jack', 'Queen', 'King', 'Ace'];
        const RANK_VALUES = {'7':7, '8':8, '9':9, '10':10, 'Jack':11, 'Queen':12, 'King':13, 'Ace':14};

        // Classes
        class Card {
            constructor(suit, rank) {
                this.suit = suit;
                this.rank = rank;
                this.value = RANK_VALUES[rank];
            }
            toString() { return `${this.rank} of ${this.suit}`; }
        }

        class Deck {
            constructor() {
                this.cards = [];
                for (let suit of SUITS) {
                    for (let rank of RANKS) {
                        this.cards.push(new Card(suit, rank));
                    }
                }
            }
            shuffle() { this.cards.sort(() => Math.random() - 0.5); }
            deal(num) { return this.cards.splice(0, num); }
        }

        class Player {
            constructor(name) {
                this.name = name;
                this.hand = [];
                this.score = 0;
                this.discards = []; // For ecarté
            }
            addCards(cards) { 
                this.hand = [...this.hand, ...cards].sort((a,b) => b.value - a.value); // Sort descending for better display
            }
            declareCombinations() {
                // Simplified declaration for Tierces (3-card sequence)
                let points = 0;
                for (let suit of SUITS) {
                    let suitCards = this.hand.filter(c => c.suit === suit).sort((a,b) => a.value - b.value);
                    for (let i = 0; i < suitCards.length - 2; i++) {
                        if (suitCards[i+1].value === suitCards[i].value + 1 && suitCards[i+2].value === suitCards[i].value + 2) {
                            points += 10;
                        }
                    }
                }
                return points;
            }
            getLegalCards(ledSuit) {
                if (!ledSuit) return this.hand; // Leading card
                
                const followCards = this.hand.filter(card => card.suit === ledSuit);
                
                // Must follow suit if able
                return followCards.length > 0 ? followCards : this.hand; 
            }
        }

        // Game class
        class PiquetGame {
            constructor() {
                this.players = [new Player('Player 1'), new Player('Player 2 (AI)')];
                this.leader = 0; // The player who leads the current trick
                this.declarer = 0; // The player whose turn it is in Ecarté/Declarations
                this.tricksWon = [0, 0];
                this.trickCards = []; // [card_player_who_led, card_second_player]
                this.ledSuit = null;
                this.talon = []; // Remaining cards for ecarté
                this.phase = 'ecarte'; // Phases: ecarte, declare, tricks
                this.p2Drawn = false; // Flag to track if Player 2 has done Ecarté
            }
            startRound() {
                this.deck = new Deck();
                this.deck.shuffle();
                this.players.forEach(p => p.hand = this.deck.deal(12));
                this.talon = this.deck.cards; // 8 cards left
                this.phase = 'ecarte';
                this.declarer = 0;
                this.leader = 0; // Player 1 (Elder Hand) leads first
                this.tricksWon = [0, 0];
                this.trickCards = [];
                this.ledSuit = null;
                this.p2Drawn = false;
                this.players.forEach(p => p.discards = []);
                this.updateUI();
            }
            exchangeCards(playerIndex, cardsToDiscard) {
                let player = this.players[playerIndex];
                let drawLimit = playerIndex === 0 ? 5 : this.talon.length; // Player 2 can only draw what remains

                if (cardsToDiscard.length > drawLimit) {
                    alert(`${player.name} can only discard/draw up to ${drawLimit} cards.`);
                    return false;
                }

                // Remove discarded cards from hand
                player.hand = player.hand.filter(card => !cardsToDiscard.includes(card));

                // Draw new cards and add discards to player's pile
                player.addCards(this.talon.splice(0, cardsToDiscard.length));
                player.discards = cardsToDiscard; // Keep track of discards for UI/rules
                
                return true;
            }
            doEcarte() {
                let player = this.players[this.declarer];
                let selectedCards = player.hand.filter((c, idx) => document.getElementById('hand-display').children[idx].classList.contains('selected'));
                
                if (this.declarer === 0 && selectedCards.length === 0) {
                    // Elder hand can pass
                    this.exchangeCards(0, []);
                    this.declarer = 1;
                    this.updateUI();
                    this.autoEcarte();
                    return;
                }

                if (selectedCards.length === 0) {
                    alert('Select at least one card to discard.');
                    return;
                }

                if (this.exchangeCards(this.declarer, selectedCards)) {
                    if (this.declarer === 0) {
                        // Player 1 (Elder) moves to Player 2
                        this.declarer = 1;
                        this.updateUI();
                        this.autoEcarte();
                    } else {
                        // Player 2 (Younger) is done, move to declarations
                        this.phase = 'declare';
                        document.getElementById('ecarte-btn').style.display = 'none';
                        document.getElementById('declare-btn').style.display = 'block';
                        this.updateUI();
                    }
                }
            }
            autoEcarte() {
                if (this.declarer === 1 && this.phase === 'ecarte') {
                    // Player 2 AI discards 1 or 2 low cards (very simple AI)
                    let p2 = this.players[1];
                    let cardsToDiscard = p2.hand.slice(p2.hand.length - 2); // Discard two lowest-value cards

                    // Player 2 can only discard if Player 1 has left cards in the talon
                    if (this.talon.length > 0) {
                        this.exchangeCards(1, cardsToDiscard.slice(0, Math.min(cardsToDiscard.length, this.talon.length)));
                    } else {
                        this.exchangeCards(1, []); // Draw 0 if talon is empty
                    }

                    this.phase = 'declare';
                    document.getElementById('ecarte-btn').style.display = 'none';
                    document.getElementById('declare-btn').style.display = 'block';
                    this.updateUI();
                }
            }
            declarePhase() {
                // Simplified declaration: both players score based on their tierces
                this.players.forEach(p => {
                    let points = p.declareCombinations();
                    p.score += points;
                    document.getElementById('trick-result').innerText += `${p.name} declares ${points} points. `;
                });
                
                this.phase = 'tricks';
                document.getElementById('declare-btn').style.display = 'none';
                this.updateUI();
                this.doTrickPlay(); // Start trick sequence
            }
            
            doTrickPlay() {
                document.getElementById('trick-result').innerText = '';
                
                if (this.players[0].hand.length === 0) {
                    this.endRound();
                    return;
                }

                if (this.leader === 1) {
                    // AI turn (Player 2)
                    let p2 = this.players[1];
                    let cardToPlay;
                    let legalCards = p2.getLegalCards(this.ledSuit);
                    
                    // Simple AI: Play a random legal card
                    cardToPlay = legalCards[Math.floor(Math.random() * legalCards.length)];
                    
                    // Find index in full hand to splice
                    let idx = p2.hand.findIndex(c => c === cardToPlay);
                    this.playCard(1, idx);
                    
                    if (this.trickCards.length === 2) {
                        setTimeout(() => this.resolveTrick(), 1000);
                    }
                }
            }

            playCard(playerIndex, cardIndex) {
                let player = this.players[playerIndex];
                let card = player.hand.splice(cardIndex, 1)[0];
                
                if (this.trickCards.length === 0) {
                    this.ledSuit = card.suit;
                    this.trickCards.push({card: card, player: playerIndex, isLead: true});
                } else {
                    this.trickCards.push({card: card, player: playerIndex, isLead: false});
                }

                this.updateUI();

                if (this.trickCards.length === 2) {
                    setTimeout(() => this.resolveTrick(), 1000);
                } else if (playerIndex === 0) {
                    // Player 1 played first, now it's Player 2 (AI)'s turn
                    this.doTrickPlay(); 
                }
            }
            
            resolveTrick() {
                let card1 = this.trickCards[0];
                let card2 = this.trickCards[1];
                let winner = card1.player;
                
                if (card2.card.suit === card1.card.suit && card2.card.value > card1.card.value) {
                    winner = card2.player;
                }
                
                this.tricksWon[winner]++;
                this.players[winner].score++; // 1 point for winning the trick
                
                if (this.players[0].hand.length === 0) {
                    // 10 points for the last trick
                    this.players[winner].score += 10; 
                    this.endRound();
                } else {
                    document.getElementById('trick-result').innerText = `${this.players[winner].name} wins the trick! (${this.players[0].name} ${this.tricksWon[0]} vs ${this.players[1].name} ${this.tricksWon[1]})`;
                    this.leader = winner; // Winner leads next trick
                    this.trickCards = [];
                    this.ledSuit = null;
                    this.updateUI();
                    this.doTrickPlay(); // Continue sequence
                }
            }
            endRound() {
                // Brelan/Carte Blanche (Skipped for simplicity)
                
                // Capot (Winning all tricks)
                if (this.tricksWon[0] === 12) {
                    this.players[0].score += 40; // Total 12+40=52 for Capot
                    alert('Capot! Player 1 wins all tricks (+40).');
                } else if (this.tricksWon[1] === 12) {
                    this.players[1].score += 40;
                    alert('Capot! Player 2 wins all tricks (+40).');
                } else {
                    // Majority of tricks (Dix-de-der: 10 points for last trick already added)
                    let winner = this.tricksWon[0] > this.tricksWon[1] ? 0 : 1;
                    this.players[winner].score += 10; // 10 points for most tricks
                }

                this.updateUI();
                alert(`Round Over! Player 1: ${this.players[0].score} | Player 2: ${this.players[1].score}`);
                
                if (Math.max(...this.players.map(p => p.score)) >= 100) {
                    alert(`${this.players.find(p => p.score >= 100).name} wins the game!`);
                } else {
                    this.startRound();
                }
            }
            
            updateUI() {
                const p1 = this.players[0];
                const p2 = this.players[1];
                document.getElementById('scores').innerText = `Player 1: ${p1.score} | Player 2 (AI): ${p2.score}`;
                document.getElementById('current-player').innerText = `${this.players[this.leader].name}'s turn (${this.phase})`;
                
                let handDiv = document.getElementById('hand-display');
                handDiv.innerHTML = '';
                
                // Enable/Disable Ecarte button
                document.getElementById('ecarte-btn').disabled = (this.declarer === 1 && this.phase === 'ecarte');

                if (this.phase === 'ecarte' || this.phase === 'tricks') {
                    const activePlayer = this.players[this.declarer]; // Human player is always Player 1 (index 0)

                    // Only display cards for the human player (Player 1)
                    if (this.declarer === 0) {
                        let legalCards = this.phase === 'tricks' ? p1.getLegalCards(this.ledSuit) : p1.hand;
                        
                        p1.hand.forEach((card, idx) => {
                            let cardDiv = this.createCardDiv(card);
                            
                            if (this.phase === 'ecarte') {
                                cardDiv.onclick = () => this.selectDiscard(idx);
                                if (p1.discards.includes(card)) cardDiv.classList.add('selected');
                            } else if (this.phase === 'tricks') {
                                if (this.leader === 0) { // If P1 leads
                                    cardDiv.onclick = () => this.playCard(0, idx);
                                } else if (this.leader === 1) { // If P2 led
                                    if (legalCards.includes(card)) {
                                        cardDiv.onclick = () => this.playCard(0, idx);
                                    } else {
                                        cardDiv.classList.add('disabled');
                                    }
                                }
                            }
                            handDiv.appendChild(cardDiv);
                        });
                    }
                }
                
                // Update Trick Area
                const p1TrickDiv = document.getElementById('p1-trick-card');
                const p2TrickDiv = document.getElementById('p2-trick-card');
                p1TrickDiv.style.display = 'none';
                p2TrickDiv.style.display = 'none';
                
                this.trickCards.forEach(tc => {
                    let div = tc.player === 0 ? p1TrickDiv : p2TrickDiv;
                    this.renderCardDiv(div, tc.card);
                    div.style.display = 'flex';
                });
            }
            
            createCardDiv(card) {
                let cardDiv = document.createElement('div');
                cardDiv.className = 'card';
                this.renderCardDiv(cardDiv, card);
                return cardDiv;
            }

            renderCardDiv(div, card) {
                div.innerHTML = `
                    <div class="rank">${card.rank}</div>
                    <div class="suit ${card.suit.toLowerCase()}">${getSuitSymbol(card.suit)}</div>
                `;
                div.classList.remove('hearts', 'diamonds', 'clubs', 'spades');
                div.classList.add(card.suit.toLowerCase());
            }
            
            selectDiscard(idx) {
                let player = this.players[this.declarer];
                let cardDiv = document.getElementById('hand-display').children[idx];
                let card = player.hand[idx];
                
                if (cardDiv.classList.contains('selected')) {
                    cardDiv.classList.remove('selected');
                    player.discards = player.discards.filter(c => c !== card);
                } else if (player.discards.length < 5) {
                    cardDiv.classList.add('selected');
                    player.discards.push(card);
                } else {
                    alert('You can discard up to 5 cards.');
                }
                // Discards array is used for logic only, the actual removal from hand happens in doEcarte
            }
        }

        // Helper
        function getSuitSymbol(suit) {
            const symbols = { 'Hearts': '♥', 'Diamonds': '♦', 'Clubs': '♣', 'Spades': '♠' };
            return symbols[suit] || suit;
        }

        // Initialize
        let game = new PiquetGame();
        game.startRound();

        document.getElementById('ecarte-btn').onclick = () => game.doEcarte();
        document.getElementById('declare-btn').onclick = () => game.declarePhase();
    </script>
</body>
</html>
